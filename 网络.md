# TCP
## 重要字段

- 序号(sequence number)：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
- 确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
 - URG：紧急指针（urgent pointer）有效。
 - ACK：确认序号有效。（为了与确认号ack区分开，我们用大写表示）
 - PSH：接收方应该尽快将这个报文交给应用层。
 - RST：重置连接。
 - SYN：发起一个新连接。
 - FIN：释放一个连接。
## 三次握手
[三次握手](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
## 为什么是三次握手？不是两次、四次？
_原因一：避免历史连接_
[why](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)
# HTTP
## 跨域解决方法

-   题目：[什么是跨域，如何解决](https://q.shanyue.tech/fe/dom/216.html)

**协议**，**域名**，**端口**，三者有一不一样，就是跨域

案例一：`www.baidu.com` 与 `zhidao.baidu.com` 是跨域

目前有两种最常见的解决方案：

1.  CORS，在服务器端设置几个响应头，如 `Access-Control-Allow-Origin: *`
2.  Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名
3.  JSONP，详解见 [JSONP 的原理是什么，如何实现](https://github.com/shfshanyue/Daily-Question/issues/447)
### JSONP
https://q.shanyue.tech/fe/dom/447.html#%E4%B8%80%E4%B8%AA-jsonp-%E8%AF%B7%E6%B1%82

## get post

get参数长度限制不是因为http协议的限制，不同的浏览器有不同的限制

## etag

当使用 ETag 字段实现的协商缓存的过程：

-   当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
-   当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
    -   如果没有过期，则直接使用本地缓存；
    -   如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
-   服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
    -   **如果值相等，则返回 304 Not Modified，不会返回资源**；
    -   如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
-   如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

###  etag生成原理 
一般是：
对于静态文件（如css、js、图片等），ETag的生成策略是：content-length的16进制 + last-modified

对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值
hash比较消耗性能