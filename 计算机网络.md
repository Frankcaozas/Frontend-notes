# TCP
## 重要字段

- 序号(sequence number)：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
- 确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
 - URG：紧急指针（urgent pointer）有效。
 - ACK：确认序号有效。（为了与确认号ack区分开，我们用大写表示）
 - PSH：接收方应该尽快将这个报文交给应用层。
 - RST：重置连接。
 - SYN：发起一个新连接。
 - FIN：释放一个连接。
## 三次握手
[三次握手](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
![[Pasted image 20230413125506.png]]
## 为什么是三次握手？不是两次、四次？
_原因一：避免历史连接_
_原因二：同步双方初始序列号_
_原因三：避免资源浪费
_
TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。
不使用「两次握手」和「四次握手」的原因：
-   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
-   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。
[why](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)
## 四次挥手
![[Pasted image 20230413125601.png]]
[四次挥手过程](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
###  为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。
-   关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
-   服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

但是**在特定情况下，四次挥手是可以变成三次挥手的**，具体情况可以看这篇：[TCP 四次挥手，可以变成三次吗？(opens new window)](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)

# HTTP
## 键入网址到网页显示，期间发生了什么

## HTTP 常见的状态码有哪些？

![五大类 HTTP 状态码](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png)

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

-   「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
    
-   「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
    
-   「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
    

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

-   「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
    
-   「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
    

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

-   「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

-   「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
    
-   「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
    
-   「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
    

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

-   「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
    
-   「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
    
-   「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
    
-   「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。
## 跨域解决方法

-   题目：[什么是跨域，如何解决](https://q.shanyue.tech/fe/dom/216.html)

**协议**，**域名**，**端口**，三者有一不一样，就是跨域

案例一：`www.baidu.com` 与 `zhidao.baidu.com` 是跨域

目前有两种最常见的解决方案：

1.  CORS，在服务器端设置几个响应头，如 `Access-Control-Allow-Origin: *`
2.  Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名
3.  JSONP，详解见 [JSONP 的原理是什么，如何实现](https://github.com/shfshanyue/Daily-Question/issues/447)
### JSONP
https://q.shanyue.tech/fe/dom/447.html#%E4%B8%80%E4%B8%AA-jsonp-%E8%AF%B7%E6%B1%82

## get post

get参数长度限制不是因为http协议的限制，不同的浏览器有不同的限制


## 强制缓存
[强制缓存](https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98)
### stale while revalidate
（SWR）是一种用于Web缓存的机制，通常用于优化网络性能和用户体验。
SWR机制的核心思想是允许从缓存中返回“陈旧”（即过期）的数据，同时在后台更新最新数据，以便在下一次请求时返回新数据。这可以提高应用程序的响应速度和性能，并减少用户等待时间。

time < max-age    直接用缓存
max-age< time < max-age + stale-while-revalidate  在后台请求更新缓存
time > max-age + stale-while-revalidate 会立即发出一个请求，并在数据返回后将其存储在缓存中，以备下一次使用。

#### 优点
它可以有效地降低网络请求的频率，提高应用程序的性能和响应速度，并减少数据传输的成本。它也可以帮助开发人员更好地管理应用程序中的数据，从而使代码更加清晰简洁。

## etag

当使用 ETag 字段实现的协商缓存的过程：

-   当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
-   当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
    -   如果没有过期，则直接使用本地缓存；
    -   如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
-   服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
    -   **如果值相等，则返回 304 Not Modified，不会返回资源**；
    -   如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
-   如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

###  etag生成原理 
一般是：
对于静态文件（如css、js、图片等），ETag的生成策略是：content-length的16进制 + last-modified

对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值
hash比较消耗性能

### etag精度比 Last-Modified 高的原因
Last-Modified 精度只到秒

## HTTP/1.1、HTTP/2、HTTP/3 演变

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

-   使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
-   支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：

-   请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
-   发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
-   服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
-   没有请求优先级控制；
-   请求只能从客户端开始，服务器只能被动响应。

### HTTP/2 做了什么优化？

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

![HTT/1 ~ HTTP/2](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png)

那 HTTP/2 相比 HTTP/1.1 性能上的改进：

-   头部压缩
	-  动态表编码
	- 静态表编码
-   二进制格式
-   并发传输
	- **多个 Stream 复用一条 TCP 连接，达到并发的效果**
-   服务器主动推送资源
### http3
-   HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
-   HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

![HTTP/1 ~ HTTP/3](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png)

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

QUIC 有以下 3 个特点。
-   无队头阻塞
-   更快的连接建立
-   连接迁移
# CDN
CDN（Content Delivery Network，内容分发网络）是指一种分布式的网络架构，通过在网络中部署大量的节点服务器，将用户所请求的内容分发到最接近用户的节点服务器上进行缓存，以提高用户访问这些内容的速度和质量。

CDN的主要功能是加速互联网内容的传输，减少网络拥堵，提高用户的访问速度和体验。具体来说，CDN可以将网站的静态资源（如图片、视频、JS、CSS等）缓存到各个节点服务器上，并通过负载均衡技术将用户请求分发到最优的节点服务器上进行响应，从而提高了用户的访问速度。

此外，CDN还可以提供安全加固、防止DDoS攻击等功能，保障网站的稳定和安全性。

# 网络安全
## xss
XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的Web安全漏洞，攻击者通过在Web应用程序中注入恶意的客户端脚本，使得攻击者能够在受害者的浏览器中执行恶意脚本，从而窃取用户的敏感信息，如cookies、会话令牌、密码等，甚至可以让攻击者获得对受害者的控制权。攻击者可以通过各种手段，如在表单输入框中输入恶意代码、在URL参数中注入恶意代码、在评论、留言板等地方插入恶意脚本等方式进行攻击。因此，开发者需要注意输入验证、输出转义等安全措施来防止XSS攻击。

## csrf
CSRF（Cross-Site Request Forgery）跨站请求伪造是一种Web应用程序安全漏洞，攻击者利用用户已经登录的身份，在用户不知情的情况下发送恶意请求，从而执行某些敏感操作或者窃取用户的敏感信息。攻击者通常会通过伪装成用户信任的网站或者诱导用户点击恶意链接的方式进行攻击。比如，攻击者可以在一个看似正常的页面上插入一个表单，然后通过JavaScript代码自动提交这个表单，完成攻击。为了防范CSRF攻击，Web应用程序可以采用一些预防措施，
### 解决方式
如CSRF Token、Referer检查、验证码等方式。

CSRF（Cross-site request forgery）攻击通常可以通过引入Referer检查来进行防御。在HTTP请求头中，Referer是指从哪个页面链接跳转过来的信息。服务器可以通过检查请求头中的Referer信息来确定请求的来源是否合法。

要使用Referer来解决CSRF攻击，可以在服务器端检查请求的Referer是否与当前站点的域名匹配。如果不匹配，则拒绝请求。

以下是一些具体的步骤来使用Referer来防御CSRF攻击：
1.  服务器在返回表单时，在表单中添加一个隐藏的字段，例如_csrf_token，并将其设置为一个随机生成的字符串。
2.  当用户提交表单时，将_csrf_token一起提交到服务器。
3.  服务器接收到请求后，验证请求头中的Referer是否与当前站点的域名匹配。
4.  如果Referer匹配，则验证_csrf_token是否与表单中提交的_csrf_token相等。
5.  如果_csrf_token相等，则请求合法，执行相应的操作；否则，拒绝请求。
通过以上的步骤，可以有效地防止CSRF攻击。但需要注意的是，由于Referer信息可以被修改或删除，因此Referer检查并不能完全保证防御CSRF攻击的安全性，还需要结合其他安全措施一起使用。