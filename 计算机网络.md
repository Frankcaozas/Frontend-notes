# TCP
## 重要字段

- 序号(sequence number)：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
- 确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
 - URG：紧急指针（urgent pointer）有效。
 - ACK：确认序号有效。（为了与确认号ack区分开，我们用大写表示）
 - PSH：接收方应该尽快将这个报文交给应用层。
 - RST：重置连接。
 - SYN：发起一个新连接。
 - FIN：释放一个连接。
## 三次握手
[三次握手](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
## 为什么是三次握手？不是两次、四次？
_原因一：避免历史连接_
_原因二：同步双方初始序列号_
_原因三：避免资源浪费
_
TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。
不使用「两次握手」和「四次握手」的原因：
-   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
-   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。
[why](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)
## 四次挥手
[四次挥手过程](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
###  为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。
-   关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
-   服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

但是**在特定情况下，四次挥手是可以变成三次挥手的**，具体情况可以看这篇：[TCP 四次挥手，可以变成三次吗？(opens new window)](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)

# HTTP
## 键入网址到网页显示，期间发生了什么
## 跨域解决方法

-   题目：[什么是跨域，如何解决](https://q.shanyue.tech/fe/dom/216.html)

**协议**，**域名**，**端口**，三者有一不一样，就是跨域

案例一：`www.baidu.com` 与 `zhidao.baidu.com` 是跨域

目前有两种最常见的解决方案：

1.  CORS，在服务器端设置几个响应头，如 `Access-Control-Allow-Origin: *`
2.  Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名
3.  JSONP，详解见 [JSONP 的原理是什么，如何实现](https://github.com/shfshanyue/Daily-Question/issues/447)
### JSONP
https://q.shanyue.tech/fe/dom/447.html#%E4%B8%80%E4%B8%AA-jsonp-%E8%AF%B7%E6%B1%82

## get post

get参数长度限制不是因为http协议的限制，不同的浏览器有不同的限制


## 强制缓存
[强制缓存](https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98)
### stale while revalidate
（SWR）是一种用于Web缓存的机制，通常用于优化网络性能和用户体验。
SWR机制的核心思想是允许从缓存中返回“陈旧”（即过期）的数据，同时在后台更新最新数据，以便在下一次请求时返回新数据。这可以提高应用程序的响应速度和性能，并减少用户等待时间。

time < max-age    直接用缓存
max-age< time < max-age + stale-while-revalidate  在后台请求更新缓存
time > max-age + stale-while-revalidate 会立即发出一个请求，并在数据返回后将其存储在缓存中，以备下一次使用。

#### 优点
它可以有效地降低网络请求的频率，提高应用程序的性能和响应速度，并减少数据传输的成本。它也可以帮助开发人员更好地管理应用程序中的数据，从而使代码更加清晰简洁。

## etag

当使用 ETag 字段实现的协商缓存的过程：

-   当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
-   当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
    -   如果没有过期，则直接使用本地缓存；
    -   如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
-   服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
    -   **如果值相等，则返回 304 Not Modified，不会返回资源**；
    -   如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
-   如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

###  etag生成原理 
一般是：
对于静态文件（如css、js、图片等），ETag的生成策略是：content-length的16进制 + last-modified

对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值
hash比较消耗性能

### etag精度比 Last-Modified 高的原因
Last-Modified 精度只到秒